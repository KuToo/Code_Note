#### 二分查找
    `
        elements;
        left=1,(左边界)
        right=len(emements),(右边界)
        k(要找的元素)
        while(left<=right){
            mid=(left+right)/2
            if(k<mid){
                right=mid-1
            }else if(k>mid){
                left=mid-1
            }else{
                return mid
            }
        }
        return not found;
    `
#### 二叉树
- 定义：一个有穷的结点集合，集合可以为空，若不为空，则它是由 **根结点**  和称其为**左子树** 和 **右子树** 的两个不相交的二叉树组成  

- 五种基本形态：（1）空二叉树，（2）只有根结点，（3）有根结点和左节点，（4）有根结点和右节点，（5）有根结点，左节点，右节点

- 特殊的二叉树：
（1）斜二叉树（往一边倒）
（2）完美二叉树
（3）完全二叉树

- 二叉树的几个重要性质
(1)一个二叉树第i层的最大节点数为：2^(i-1),i>=1
(2)深度为K的二叉树有最大结点总数为2^k -1,k>=1
(3)对任何费控二叉树，若n0表示叶节点的个数，n2表示度为2的非叶节点个数，则两者之间满足关系n0=n2+1

- 二叉树的抽象数据类型定义
(1)类型名称：二叉树
(2)数据对象集：一个有穷的结点集合，若不为空，则由**根结点和其左、右二叉子树**组成
(3)操作集：重要操作有：a.判断二叉树是否为空，b.遍历，按某书序访问每个节点，c.创建一个二叉树
(4)常用的遍历方法有（4种）：
先序（根->左子树->右子树），中序（左子树->根->右子树），后序（左子树->右子树->根），层次（从上到下，从左到右）

- 二叉树的存储结构
(1)顺序存储结构
    完全二叉树：按从上至下，从左到右顺序存储n各节点的完全二叉树的结点父子关系
    数组存储，链表存储

- 二叉树的遍历（递归）
(1)先序遍历
(2)中序遍历
(3)后序遍历
- 二叉树的遍历（非递归）
（1）中序遍历：
    遇到一个结点，把它压栈，并去遍历它的左子树
    当左子树遍历结束后，雄栈顶弹出这个结点并去访问它
    然后按其右指针再去中序遍历该节点的右子树
- 二叉树的层序遍历
(1)根结点入队
(2)从队列中取出一个元素
(3)访问该元素所指的结点
(4)若该节点所指结点的左右孩子结点非空，则将其左右孩子顺序入队

- 二叉搜索树
定义：一棵二叉树，可以为空，如果不为空，满足一下性质：
    (1)非空左子树的所有的键值小于其根结点的键值
    (2)非空右子树的所有的键值大于其根结点的键值
    (3)左右子树都是二叉搜索树
查找操作：
    (1)指定元素查找（find）
    (2)最大元素查找（findMax）
    (3)最小元素查找（findMin）
插入操作：
删除操作：
    (1)叶节点直接删除
    (2)只有一个子结点的结点，用该子节点替换掉要删除的结点
    (3)有左右子结点的结点，用另外一个结点替代删除的结点：**右子树的最小元素**或者**左子树的最大元素**

- 平衡二叉树
 平衡因子：Hl-Hr,平衡二叉树的平衡因子<=1
 平衡二叉树的调整（调整之后还必须是搜索二叉树）
 (1)RR旋转（破坏者在第一个被破坏者的右结点的右节点）
 (2)LL旋转（破坏者在第一个被破坏者的左结点的左节点）
 (3)LR旋转（破坏者在第一个被破坏者的左结点的右节点）
 (4)LR旋转（破坏者在第一个被破坏者的右结点的左节点）

- 堆
堆的两个特性
    (1)结构性:用数组表示的完全二叉树
    (2)有序性:任一节点的关键字是其子树所有结点的最大值（或最小值）
        最大堆:(大顶堆)最大值
        最小堆:(小顶堆)最小值

#### 图

#### 排序
- 简单排序
    (1)冒泡排序
    `
    function bubble_sort($data){
        n=len($data);
        for($i=n-1;$i>0;$i--){
            $flag=0;
            for($j=0;$j<$i,$j++){
                if($data[$j]>$data[$j+1]){
                    $temp=$data[$j];
                    $data[$j]=$data[$j+1];
                    $data[$j+1]=$temp;
                    $flag=1;
                }
            } 
            if($flag==0)break;
        }
    }
    `
    (2)插入排序
    `
    function insertion_sort($data,$a){
        $n=len($data);
        for($i=1;$i<$n;$i++){
            for($j=$i;$j>0;$j--){
                if($data[$j-1]<$a){
                    $data[$j]=$data[$j-1];
                }
            }    
        }
    }
    `
- 简单排序
- 简单排序



